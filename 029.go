package main

import (
    "errors"
    "fmt"
    "math"
    "math/big"
)

/*
Consider all integer combinations of a^b for 2<=a<=5 and 2<=b<=5:

    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the
following sequence of 15 distinct terms:

    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2<=a<=100 and
2<=b<=100?
*/

func isDuplicate(a int64, b int64, aMax int64, bMin int64, bMax int64) bool {
    // If we're dealing with an even number for b, we potentially have a
    // duplicate. E.g.,
    //
    //     4 ^ 2 = (2 * 2) * (2 * 2)
    //           = 2 * 2 * 2 * 2
    //           = 2 ^ 4
    //           = 16
    //
    // and
    //
    //     9 ^ 3 = (3 ^ 2) ^ 3
    //           = 3 ^ 6
    //           = 729.
    //
    // Thus, the number we would be duplicating is sqrt(a). If this is still
    // within the allowed range (e.g., 2 * b <= bMax), then we have a duplicate.
    //
    //     a ^ b = (sqrt(a) ^ 2) ^ b
    //           = sqrt(a) ^ (2 * b)

    if int64(math.Sqrt(float64(a))) * int64(math.Sqrt(float64(a))) == a && 2 * b <= bMax {
        /* fmt.Printf(
            "Found duplicate: %d^%d=%d^%d\n",
            a,
            b,
            int64(math.Sqrt(float64(a))),
            2 * b,
        ) */

        return true
    }

    // Additionally, if we have a=x^y where y <= bMax, we have a duplicate.
    // I.e., 16^2=(2^4)^2=256 has already been addressed as 2^8. Thus, we need a
    // way to determine if a number is a simple power of another number.
    // However, if we have 15^2=(3^1*5^1)^2, we do not have a duplicate. So, we
    // only have a duplicate, if the integer factorisation of a is a single
    // number.

    factors := getPrimeFactorisation(a)

    if len(factors) == 1 {
        for _, power := range factors {
            if power == 1 || b * int64(power) > bMax {
                // The number is prime, we have not found a duplicate.
                return false
            }

            for b * int64(power) > bMax {
                // We may have found a duplicate, but this particular
                // factorisation does not fit within the limits. E.g.,
                // 64^17=(2^6)^17=2^102 (for 2<=b<=100, this does not fit).
                // Thus, we should make it ((2^2)*(2^4))^17=
                break
            }

            /* fmt.Printf(
                "Found duplicate: %d^%d=(%d^%d)^%d=%d^%d\n",
                a,
                b,
                base,
                power,
                b,
                base,
                b * int64(power),
            ) */
        }

        return true
    }

    return false
}

func getPrimeFactorisation(n int64) map[int64]int {
    bigI := big.NewInt(0)

    factors := make(map[int64]int)

    if bigI.ProbablyPrime(int(n)) {
        factors[n] = 1
        return factors
    }

    for true {
        factor, err := getNonTrivialFactor(n, 1)
        if err != nil {
            break
        }
        if _, ok := factors[factor]; ok {
            factors[factor]++
        } else {
            factors[factor] = 1
        }
        n /= factor
    }

    if n != 1 {
        if _, ok := factors[n]; ok {
            factors[n]++
        } else {
            factors[n] = 1
        }
    }

    return factors
}

func getNonTrivialFactor(n int64, iter int) (int64, error) {
    // Using Pollard's rho algorithm

    x         := int64(2)
    y         := int64(2)
    d         := big.NewInt(int64(1))
    cycleSize := 2;

    g := func (x int64) int64 {
        return (x * x + 1) % n
    }

    if iter == 2 {
        g = func (x int64) int64 {
            return (x * x - 1) % n
        }
    }

    bigN := big.NewInt(n)

    for d.Int64() == int64(1) {
        for count := 1; count <= cycleSize && d.Int64() == int64(1); count++ {
            x = g(x)

            if x == y {
                // There is strange behaviour in math/big's GCD function.
                d = bigN
            } else {
                bigAbs := big.NewInt(int64(math.Abs(float64(x - y))))
                d       = d.GCD(nil, nil, bigAbs, bigN)
            }
        }

        cycleSize *= 2
        y          = x
    }

    if d.Int64() == n || d.Int64() == int64(0) {
        if iter == 2 {
            return 0, errors.New("Could not find prime factor")
        }

        return getNonTrivialFactor(n, 2)
    }

    return d.Int64(), nil
}

func countTerms(aMin int64, aMax int64, bMin int64, bMax int64) int64 {
    terms := make(map[string]string)
    count := int64(0)

    for a := aMin; a <= aMax; a++ {
        for b := bMin; b <= bMax; b++ {
            if isDuplicate(a, b, aMax, bMin, bMax) {
                continue
            }
            bigA := big.NewInt(a)
            bigB := big.NewInt(b)
            term := big.NewInt(0)
            term = term.Exp(bigA, bigB, nil)
            if _, ok := terms[term.String()]; !ok {
                count++
                terms[term.String()] = "" /* fmt.Sprintf("%d^%d", a, b) */
            /* } else {
                fmt.Printf("Duplicate not located: %d^%d (duplicate of %s)\n", a, b, existingTerm) */
            }
        }
    }

    return count
}

func main() {
    count := countTerms(2, 100, 2, 100)
    fmt.Printf("Count: %d\n", count)
}
